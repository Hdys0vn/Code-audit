# 序列化的意义

序列化的存在 1.为了数据的持久性  2.跨平台传输  3.方便存储备份和读取

序列化的本质是传输与存储技术 比如JSON xml  二进制 字节数组

## 执行过程与漏洞成因

序列化的执行过程 选择序列化格式 ------遍历数据对象 进行序列化-----拼接为完整的序列化字节序列----进行存储或传输

反序列化过程 读取序列化的字节序列和格式 ----解释序列化数据------创建新的数据或对象状态进行恢复 

反序列化后的值由自身提供 与原先预定义的无关（过程） 并且类方法调用才会触发（避免不必要的开销和副作用） 在这个过程中 值如果是可 控的话 便会造成反序列化漏洞

简单来说 反序列化漏洞的原因便是 可控恶意的字节序列被反序列化触发造成漏洞
POP链是指调用一系列方法  通过反序列化植入 从而达到目的

虽然一些序列化库和框架支持多种编程语言 以及本身蕴含了某种缺陷 攻击者可以借助自动化工具来进行POP链的构 但调用某些敏感函数需要特定的权限，以及pop链构造繁琐 任然会增加攻击成本



## 漏洞修复

​	验证和过滤   黑白名单    编码传输     异常报错或日志记录  

​         序列化加密和签名防止篡改和伪改     反序列化的对象进行访问控制 限制其可调用的方法和属性

​    使用安全的序列化库或格式 比如JSON在对不信任的字节序列进行反序列化的时候只会得到一些数据，不会触发任何逻辑或行为



# 不同语言的反序列化

## Python

Python反序列化依靠两个模块cpickle和pickle 功能一样 区别在于 编写语言不一样   但在Python3中已经没有了cpickle 

pickle有四种操作方法

模块 [`pickle`](https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle) 实现了对一个 Python 对象结构的二进制序列化和反序列化，原生原造 Python专有

| 函数 说明 |                                |
| --------- | ------------------------------ |
| dump      | 对象序列化到⽂件对象并存⼊⽂件 |
| dumps     | 对象序列化为 bytes 对象        |
| load      | 对象反序列化并从⽂件中读取数据 |
| loads     | 从 bytes 对象反序列化          |



## PHP

PHP的反序列化 

```
__wakeup() //使⽤unserialize时触发 

__sleep() //使⽤serialize时触发

__destruct() //对象被销毁时触发 

__call() //在对象上下⽂中调⽤不可访问的⽅法时触发 

__callStatic() //在静态上下⽂中调⽤不可访问的⽅法时触发

__get() //⽤于从不可访问的属性读取数据

__set() //⽤于将数据写⼊不可访问的属性

__isset() //在不可访问的属性上调⽤isset()或empty()触发

__unset() //在不可访问的属性上使⽤unset()时触发

__toString() //把类当作字符串使⽤时触发，file_exists()判断也会触发 

__invoke() //当脚本尝试将对象调⽤为函数时触发
```

通用手法

  检查自身类中的魔法方法是否可利用，无利用则看是否能引入其他类，再看其他类的魔术方法是否可利用 不断迭代 挖掘到一条POP链

```
serialize() //将⼀个对象转换成⼀个字符串

unserialize() //将字符串还原成⼀个对象
```

source点-->unserialize函数

sink点-->某个类的魔术⽅法中存在调⽤⻛险函数（system、exec、popen、file_get_contents、file_put_contents等等） 排查传播链(pop链)

类⾥⾯所有的属性的值，都是可以⾃定义的（可以定义成任何"对象"：字符串、数组、函数、另⼀ 个类/对象） 利⽤pop链挖掘通法重复第⼀点



php有个cve（CVE-2016-7124），如果序列化的字符串中表示对象属性个数的值大于真实的属性个数时，PHP会跳过wakeup方法的执行，直接进入下一个对象的反序列化，这样就可以利用其他对象的魔术方法或敏感函数来实现任意代码执行或其他危害的目的  遇到wakeup中有限制，可以看看php版本





### phar反序列化 

phar文件是一种PHP的归档文件，可以将多个PHP文件或其他资源打包成一个文件，方便分发和部署

`phar://` 协议允许在 PHP 中以类似文件系统的方式访问 PHAR 文件中的内容

phar文件的结构大致如下：

- 一个stub，用来标识这是一个phar文件，格式为 xxx<?php xxx; __HALT_COMPILER ();?> ，前面任意，但是一定要以 __HALT_COMPILER ();?> 结尾，否则PHP无法识别这是一个phar文件。
- 一个manifest，用来描述phar文件中包含的文件的信息，如文件名，大小，压缩方式等。其中，manifest中还可以包含一个用户自定义的meta-data，这个meta-data可以是任意的PHP值，通常是一个数组或对象，用来存储一些额外的信息。这个meta-data会以序列化的形式存储在phar文件中，这也是漏洞利用的关键点。
- 文件内容，即phar文件中实际包含的文件的内容，可以是PHP代码，图片，音频等任意类型的文件。
- 一个签名，用来验证phar文件的完整性，防止被篡改。

phar反序列化就是可以在不使⽤php函数unserialize()的前提下，进⾏反序列化，从⽽引起的严重的php对象注⼊漏洞。

原理 

漏洞触发点在使⽤ phar:// 协议读取⽂件的时候，⽂件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化。当内核调⽤phar_parse_metadata()解析metadata数据 时，会调⽤php_var_unserialize()对其进⾏反序列化操作，因此会造成反序列化漏洞。

利⽤条件

phar⽂件要能够上传到服务器端。  前提

phar内部要有可⽤的魔术⽅法作为“跳板”。 执行条件

⽂件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 出发条件 

有序列化数据必然会有反序列化操作，php⼤部分的⽂件系统函数在通过phar://伪协议 解析phar⽂件时，都会将meta-data进⾏反序列化，测试后受影响的函数如下

![image-20231128215456607](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231128215456607.png)

### session反序列化

PHP在session存储和读取时,都会有一个序列化和反序列化的过程，PHP在session存储和读取时,都会有一个序列化和反序列化的过程

原理，当序列化存储session数据和反序列化读取session数据的引擎不一致时，就可能导致数据无法正确地还原，或者触发一些意外的效果。

如果session的值是可控的，那么就可以构造一些特殊的字符串，来实现PHP对象注入，即在反序列化的过程中，创建一个指定的类的实例，并调用其魔术方法，如__wakeup()，__destruct()，__toString()等，从而执行任意的PHP代码。

session反序列化的利用条件是：

- session的值是可控的，可以通过GET，POST，COOKIE等方式传递给服务器。
- 服务器端的序列化引擎和反序列化引擎不一致，或者可以通过某种方式改变它们。
- 服务器端存在可以利用的魔术方法，且能够执行任意的PHP代码，不然只能自己编写魔术方法去适应解析的PHP引擎 否则可能解析失败





## java反序列化

ObjectOutputStream类的 writeObject() 方法可以实现序列化

ObjectInputStream 类的 readObject() 方法用于反序列化

实现java.io.Serializable接口才可被反序列化，而且所有属性必须是可序列化的(用transient关键字修饰的属性除外，不参与序列化过程)

重写 `readObject()` 方法的目的是允许类的开发者在反序列化的过程中执行自定义的操作，

readObject()方法被重写的的话，反序列化该类时调用便是重写后的readObject()方法。如果该方法书写不当的话就有可能引发恶意代码的执行



Java的反射机制是指在运行时，可以动态地获取和操作类的属性和方法的技术。

class是一种数据结构，包含了类的绝大数信息。JVM在加载类的时候，会将class文件中的字节码转换为class对象，并存储在方法区中。Java反射机制的本质就是 通过调用Class类，来访问和操作方法区中的class对象，从而实现动态地获取和更改类的属性和行为，绕过一些特定的权限，让代码进行执行

反射过程  获取class对象-----通过class对象获取构造函数方法------实例化对象----------调用和访问修改

反射的好处：灵活扩展  可测试维护

Java的反射机制和Java反序列化漏洞的关系是：

- Java的反射机制可以让反序列化的过程中，动态地加载和调用类的方法，从而实现代码执行的目的。
- Java的反射机制可以绕过类的访问权限，调用私有的构造方法、字段和方法，从而触发一些隐藏的漏洞或逻辑错误。
- Java的反射机制可以修改类的final修饰的字段，从而改变类的行为或状态，造成一些意想不到的后果。



## 总结

总结来说 Java的反序列化漏洞和其他语言的反序列化漏洞 本质来说是差不多的 同样是因为没有足够的验证和过滤而导致漏洞的产生，但是Java本身的语法特性 反射机制和readobject的重写 为反序列化漏洞带来了更大的可能性，readobject使得反序列化过程可以自定义操作  反射机制使得反序列化漏洞能够更加绕过一些特定的权限和方便直接调用某些方法



漏洞是系统存在缺陷 而被利用的地方   而一个漏洞产生的原因  首先是本身自我环境的问题  不正确的写法规范 特定的语言特性  采用了不安全的第三方因素如组件 插件 cms等  其次是验证和过滤 权限控制没有做到完美 给了攻击者机会， 大体来说便是内在因素和外在因素

而对于我们来说  大多数漏洞来说 他们的原理是一样的 共通的  不管是PHP的文件上传还是Java的文件上传亦或者其他第三方因素的文件上传 ,除开一些本身独特 只有他的特性才造成的漏洞外，其他漏洞对于我们来说 没有什么两样 都是一样的  影响我们的只是 他们本身的一些语言特性和规则 导致了攻击手法的不一样，但对于漏洞本身来说 我们的关注点还是在于他漏洞的本身原理   

