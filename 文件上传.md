# 不同语言的代审界限

⼀般⽽⾔，我们代码审计 基本是以我们能接触到物理设备、或者获取到设备的cmdshell权限为前提（直接查看和分析设备上运行的代码，可以更深入地检查系统和应用程序的内部运行机制，以及直接查看和操作底层系统资源）



## 脚本语言 /解释语言

对于PHP JSP ASP这种 运行模式就是动态解释引擎+脚本代码   获得cmshell或者物理设备 就可以看到所有代码



## 一次编译到处运行

java  Python .net  运行模式 是将代码编译成中间语⾔，并且在不同的操作系统上运⾏有不同的虚拟机运行机制

运行模式：中间语⾔+虚拟机 或者**虚拟机+字节码运行模式**    java  jvm   class 

比如 java被编译成字节码后，字节码中包含了⼤量关于原始java代码的描述信息，为了让虚拟机理解，但通过**反射**的⽅法，我们可能借由这些信息，重新描述出原始的java   

所以python(pyc)、net(dll/so)能反编译成原来的代码了  恢复率百分之90  

但反编译必然是有损失的，取决于反编译所⽤的软件，比如反编译cs jar包的java-decomplier.jar

**反射技术 反编译**

![image-20231112194937465](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231112194937465.png)



## **编译型语⾔**

比如 C go c++        

编译型语⾔，基本看不到代码。可以尝试ida反编译或者gdb动调之类  但反编译看到的代码也是很恶⼼的代码

对付编译成⼆进制的程序的方法

### 1.符号表  

通过ida或者linux上的⼯具objdump，如果我们遇到的程序没有去除符号表，那么我们还是可 以看到⼀些提示信息的（主要从名称推断功能）![image-20231112200813180](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231112200813180.png)



### 2.strings（mac liunx）

![image-20231112200917073](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231112200917073.png)

⼆进制⽂件中存储的字符串，如果开发者硬编码了⼀些密码或者密钥或者证书之 类的，我们通过strings就可以直接看到，当然，我们只能通过其特殊性猜测是⼀个敏感信息， 并且怎么⽤仍要去探索



### 3.配置⽂件

程序不可能孤⽴地运⾏，⼀般⽽⾔，数据库连接账号密码、⽇志⽂件、业务信息等等，都是通 过挂载形式存储在配置⽂件⾥⾯的，那么不加密的配置⽂件就有可能透露⼀些信息。



**总结 对于c/golang这种编译型语⾔的运⾏模式，我们简单记为，⽆法恢复源码，但是可以通 过符号表、字符串、配置⽂件等去尽量窥探程序的运⾏状态和运⾏⽅式。**





# 文件上传不同语⾔的webshell上传差异 

主要看 是否被服务器解析

脚本语⾔/解释型语⾔  PHP  JSP ASP

可以直接上传webshell并运⾏ （代码在服务器上面直接被解释执行 不需要预先编译）



⼀次编译到处运⾏ 

视情况⽽定： 

python基本不能直接上传webshell，因为没办法路由到webshell⽂件。 路由地址访问技术      

java要看中间件，有的中间件解析jsp的情况下，是可以通过上传jsp的webshell，有的中间件 不解析jsp就没办法

.net也是⼀样的道理，但是从经验来看，.net搭建的⽹站很多可以直接上传aspx的webshell。



编译型语⾔  没有办法上传webshell，（编译会将源代码翻译机器码或字节码 生成可执行文件 而文件上传的源代码文件 并不直接在服务器上面执行）但是在某些情况下可以通过上传+其他利⽤来进⾏rce。 比如 上传 并触发他  



⽂件上传能够到webshell

两个层⾯的问题：后缀处理（是否能绕过并上传）、运⾏环境（操作系统、中间件）（1.路由访问，2.是否解析你的代码）





## 常规检测绕过

### JS 检测的数据流程图

文件上传---> 浏览器前端进行检测 ---> 通过网络传输（可控）---> 服务端接收---> 进入后端代码路由和检测---> 写入文件  

绕过  上传文件 burp抓包  根据后端逻辑更改   没必要管JS  JS验证都是ZZ



### 解析规则

运行环境差异   不同中间件不同版本有不同的利用方式



MIME（分主子类，依靠主子类来区分文件 有自己的规则 如image/jpeg： JPEG图像     application/json： JSON数据）Content-Type

webshell上传关注的是后缀跟运⾏环境，所以这个MIME是什么，跟我们没半⽑钱 关系，应对这种检测，我们直接修改filename即可



### ⽂件头

⽂件格式的规则，⼀般在⽂件的前⼏个字节

![image-20231113102019635](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113102019635.png)

 但是对于php/asp/jsp这种解释型语⾔⽽⾔，灵活性很强，并不要求脚本代码位于⽂件的开头，我们就可以在开头使⽤图⽚⽂件的⽂件头，在中间或者后⾯的位置插⼊脚本语⾔，进⾏getshell



### 后缀检测

后缀检测失效 要检测filename字段的后缀  黑白名单

绕过 双写绕过     运行环境Windows   大小写       Apache 解析规则  多个后缀解析为PHP 



### NTFS 新技术文件系统  数据流 ADS利用

[渗透测试的WINDOWS NTFS技巧集合 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/2539)

![image-20231113102540249](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113102540249.png)

shell.php::$DATA  EXE JPEG ：：$DATA 

`shell.php::$DATA` 的方式涉及到一种特定的 NTFS 数据流技术  ADS

在NTFS中，每个文件都有一个主数据流（`$DATA`），**如果没有指定数据流的名称，通常会被认为是主数据流。同时，NTFS还支持多个备用数据流（Alternate Data Streams，ADS），每个备用数据流都有自己的名称。备**用数据流的命名格式为 `filename:streamname`，其中 `filename` 是文件名，`streamname` 是数据流的名称 

如果未指定数据流名称，则默认使用 `filename::$DATA`，**有时候Web应用程序允许用户上传文件，但它可能只检查主数据流的文件扩展名**。这导致了一个问题，即攻击者通过上传文件名为 `shell.php::$DATA` 的文件来绕过文件上传的检查，因为通常这种情况下只会检查 `shell.php` 部分而忽略了 `::$DATA` 部分。上传 `shell.php::$DATA` 后，Web服务器可能只解释文件名部分，将其当作 PHP 脚本来执行，而忽略了数据流部分。这就允许攻击者在数据流中插入 PHP 代码，绕过了文件扩展名的检查，成功执行上传的恶意脚本

列如  网站只检查文件名的扩展名部分，`malicious.php::$DATA.jpg` 欺骗服务器认为它是一个 JPEG 图片文件，从而绕过了基于文件扩展名的检查而忽略了 `::$DATA` 部分。当用户请求 `malicious.php::$DATA.jpg` 时，服务器可能执行其中的 PHP 代码，因为它认为这是一个图片文件，但实际上它包含了恶意的 PHP 代码。

**如果有一个文件名为 `example.txt`，那么该文件的主数据流就是 `example.txt:$DATA`，而可以创建额外的备用数据流，例如 `example.txt:stream1`**





## 压缩文件处理

**对压缩文件的文件名没有进行有效的过滤 导致文件名拼接 出现漏洞**

列如:解压的时候直接获取tar⾥⾯的⽂件名，然后读取内容，紧接着，直接进⾏ filepath.Join⽂件名拼接，没有对⽂件名进⾏任何校验，就出现了路径穿越写⼊⽂件

技巧点 后台导入

**对于这种⾃写web容器，思路⼀般是查看能不能上传到任意⽬录、上传后的⽂件名以及web容器本身的权限有多少**

![image-20231113201156366](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113201156366.png)

猜测功能点的逻辑代码为： 1.接收上传的tar包  2.解压    3.导⼊数据 

解压需要解决的问题： 

1.上传后的⽂件名需要是我们能⾃定义的。    2.解压如果能解压到任意⽬录那就能构成利⽤。 3.解压⽂件名中是否能够包含../

两个技术点  tar 7zip  

1.能否构造恶意的tar包，包含我们恶意的包含../的⽂件名称

2.恶意的tar包能否被正常解压

要构造恶意的tar包，⾸先要了解tar包的格式。这⾥附⼀份paper

http://blog.chinaunix.net/uid-20357359-id-1963469.html

tar包中主要的校验来⾃于⽂件size⼤⼩、checksum校验和。⼤⼩好解决，不赘述，不改 动⽂件⻓度即可，主要是校验和，解决了校验和，就解决了问题1和3。就要了解校验和的算法。



# 任意写文件的作用 （liunx）

### 1.webshell  

主要配合动态脚本⽐如php、jsp之类的使⽤，优点是需要的 权限低。缺点是需要知道web路径。还需要配合web容器，如果面对路由访问技术 会比较麻烦一点

### 2.ssh公钥 

需要权限配合 主要需要运行web容器的用户有ssh登录权限 需要开放ssh外联  列如 将本机的公钥存储到服务器的~/.ssh/authorized_keys

⽬录下。 存储后直接ssh免密登陆

### 3.计划任务 

需要权限配合 一般是root 才能写入计划任务的目录

​	1  var/spool/cron/   2./etc/crontab/	将想执⾏的bash命令按指定格式存⼊即可



### **GO代码的文件上传**

如果遇到云上系统 go语言跑在docker里面   利用点 curl 访问vps，下载适配的nc，nc反弹shell，拿到docker权限

**弱点上传点为：/*/upload  多个上传处均采⽤这⼀接⼝，对后缀没有做限制 但是GO不能动态解析，所以需要配合路径穿越**

与脚本语⾔不同的是，编译型的web应⽤，对于⽂件的处理常常为以下⽅式，写⼀段伪代码表示

![image-20231113203217160](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113203217160.png)

content为上传包中的⽂件内容，filename为上传的filename字段内容，

dst为预设⽬录upload_dir与filename的拼接，然后直接调⽤⽂件操作函数，将内容写⼊到dst⽂件中

 这⼀点与php等语⾔不相同，php等语⾔会有tmp_name作为临时⽂件名，之后的写⼊常 常需要类似move_uploaded_file的函数来⽀持，在这种情况下，⼀般程序员会对⽂件名进⾏⼀ 个basename的操作。 ⽽go等编译型语⾔，filename、content都是通过程序员⾃⼰写的代码来获取，并且⽂件 也如也常常⽤io、File等基础库函数，故经常出现漏检测的问题。

**所以在遇到go、py的等语⾔写的web应⽤的时候，这是⼀个值得关注的点，常常有路径 穿越的漏洞出现。**



## 路径穿越+⽂件上传的作用

  1.写入bash公钥			2.反弹shell         3.getshell

**路径穿越的最主要限制在于权限，启动web应⽤的⽤户权限**

技巧利用

### 1.程序覆盖

linux与windows不同的⼀点是，**当程序被执⾏后，程序⽂件已经完全载⼊到内存中，硬盘上⽂件是可以删除的。（常常被僵⽊蠕利⽤）**（Windows程序跑起来 没有办法进行写入） ⾸先可以考虑，覆盖掉web应⽤的可执⾏程序，采取DDOS等⽅式迫使服务器或者应⽤重 启，执⾏我们的恶意程序。 

所以搜索哪些正在执⾏且有权限的⽂件，并且重点关注那些会以root权限执⾏的命令。 这⾥的另⼀个tip是，**在linux下后台驻留的程序常常⽤supervisord来守护的,如果程序挂掉，会⾃动重启**。详情可以参考supervisord的配置。成功覆盖掉⽂件后，等待重启即可

缺陷是可能导致应⽤原来的功能失效





### 2.配置⽂件覆盖

如果我们不想等待 可以尝试配置⽂件覆盖，在编译后的套件服务中，常常有⼀个功能是check服务器的状 态，check服务本身的状态。 这个时候，它可能动态地去获取配置⽂件，并执⾏配置⽂件的内容。

 在本案例中，有⼀个⼀键诊断的功能，它会通过go去调⽤/usr/local/*/aabbcc程序，⽽aabbcc⼜会去调⽤同⽬录下xxx.py来实现功能。 问题是/usr/local这个⽂件夹我是没有权限的，那怎么利⽤？可以看出，他会动态地去获取⼀个我有权限覆盖的config.json，并将内容插⼊到bash命 令中，命令注入

![image-20231113205916244](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113205916244.png)



### 3.动态执⾏

动态执⾏指的是 我们可以通过应⽤中存在的某个功能，该功能会触发执⾏，其实 跟2有点类似，只是我们覆盖的是直接被执⾏的⽂件,在产品中找了许久，似乎没有存在/home/aabbcc⽬录下的会被触发执⾏的⽂件，所有被 触发执⾏的都是系统程序，都是在/usr/local或者/usr/bin等⽬录下。 

比如：后台有个上传升级包的功能。 程序升级的时候，总要执⾏⽂件吧？了解到产品在升级包中有⼀个bash⽂件，升级过程中会以root身份去执⾏这个bash⽂ 件，来进⾏各项操作。那么只要构造出合法的升级包，就可以借⽤原有的升级功能，来动态执⾏、触发我的恶意bash了

![image-20231113210357610](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113210357610.png)

公私钥加密，服务端肯定要存私钥，⽽我们知道私钥通常是⼀个⽂件。 只要是⽂件，就有可以利⽤的点。

因为我们有任意⽂件覆盖的漏洞在⼿啊 所以我们只需要在本地⽣成⼀对密钥， 然后将私钥通过任意⽂件上传和路径穿越覆盖到privatePemFile所对应的⽬录， 然后⽤公钥证书签名我们的恶意tar包，即可完成⼀次攻击。 在上传的时候，服务端会帮我完成解密、执⾏bash的操作



如果⽂件上传与路径穿越的漏洞不存在，能利⽤嘛   但要攻击者能最⼤程度地接触代码、程序。所以在这个场景下，我们假设攻击者能够拿到⽣产环境下的应⽤，也就是能拿到存储在⽬ 录中的私钥

![image-20231113210525133](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113210525133.png)

![image-20231113210618597](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113210618597.png)

你发现了吗，公钥是来⾃于私钥的，⽽且⼀般这种场景下不会有验签这⼀说的。 所以，、、 攻击者只需要拿到存在于⽣产机器上的私钥⽂件，就能利⽤命令创建公钥、创建证书，然 后⾃签名。 并且⽤证书加密包含有恶意bash的升级包，然后上传即可，构造的⼀个恶意的升级包，⾥⾯的升级bash中含有攻击性的bash

![image-20231113210635268](C:\Users\西山\AppData\Roaming\Typora\typora-user-images\image-20231113210635268.png)

# 总结

**文件上传不仅是代码逻辑问题  还受 中间件 语言版本和函数 第三方组件影响   上传存储逻辑，存储方案不同也会造成权限不同** 

**同样 无文件解析安全问题上，格式解析是一对一的 不能JPG解析PHP  除非有解析错误配置或有后缀解析漏洞才能解析  如 Apache htaccess**

拓展类的如  中间件  编辑器  CMS类   **Apache和nginx**   **编辑器 ueditor富文本编辑器 **  通达 OA-V11.2  此类 

## 1.解析方案 

文件上传  安全解析方案  目录执行权限（文件上传后存储目录不给执行权限）能控制上传文件的目录饶过 

解码还源（文件上传后利用编码传输，解码还源，文件后缀无关） 固定协议  data:image/png:base,base一串数据

## 2.存储方案

分站存储  前后端分离   看图片地址

oss对象存储 只能存储   一打开就下载

以上方案除目录设置权限如能换目录解析绕过外，其他均无解

