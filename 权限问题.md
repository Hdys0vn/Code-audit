# 权限问题 未授权

## 认证 授权  鉴权  权限控制

认证是确认用户凭证   授权是授予用户对应的等级权限   鉴权则是鉴定用户等级权限 权限控制确定用户的行为在可控制的权限范围内

认证和鉴权的区别    认证是证明 鉴权是权限确认   认证是通过独特的信息进行识别 鉴权则是鉴别授权过程中定义的某个媒介 比如cookie  session之类的凭据



### 认证 （认证因子 认证因素）

利用特定独特的信息来证明身份

证明  信息比较的过程  前提有预先的数据库存储原信息

比如 我有预留数据库里面的密码或自我生物特征  验证码 第三方凭证 oauth2认证等  

OAuth2.0认证是网络授权标准，允许用户将某些特定的网络资源授权给第三方应用，而无需将他们的用户名和密码直接提供给第三方应用。这个过程主要涉及四个角色：客户端、资源拥有者、认证服务器和授权服务器

授权模式有四种 授权码模式  简化模式  密码模式  客户端魔术

授权过程

- 第三方应用向用户请求授权----- 用户在授权服务器上登录并同意授权，授权服务器会返回一个授权码或者访问令牌给第三方应用，取决于授权模式的不同----第三方应用获得了授权码，它需要向授权服务器发送一个请求，携带授权码、应用标识和应用密钥等参数，以换取访问令牌----第三方应用使用访问令牌向资源服务器请求用户的资源，认证服务器验证令牌的有效性后，返回相应的资源给第三方应用。

高安全的场景会要求做 双因子认证  多因素验证 比如 生物特征＋短信验证码



另类认证方式 挑战/应答方式身份认证



### 授权认证    

服务器下方可信任的等级令牌  

常用临时凭证 cookie session  jwt认证 ak-sk  



### 鉴权

鉴定用户是否持有授权  授权是否有效    用户授权的等级

传统和常规上 授权和鉴权往往在同一台服务器上面 因为传统采用的是基于session的集中式授权和鉴权模式，session存储在服务器上面 但如果服务器是集群或是跨域的服务导向架构就需要session数据共享增加负担和复杂度，但现在随着云服务的发展 jwt ak-sk 可以跳出这个模式，因为他们是基于token的机制，用户登录后的token是保存客户端上面的,token更适合现在灵活轻量的分布式微服务的环境架构

真实有效 不可篡改  不可伪造 规则 打破 漏洞产生



### 权限验证控制 ACL

权限验证 将鉴权后的结果实列化，规定不同权限在范围内执行操作的大小

认证  独特标识     授权  给出对应等级的权限    鉴权 鉴定该等级的权限  权限控制 严格要求 



免密登录   挑战应答 依赖于检测逻辑的机制 一般来说有单独的key加上随机码 核心点 算法一破解 就没了

流程   你肯定知道答案

```
echo "Hello!Challenge here!"
code = ChallengeCodeGenerater() //⽣成挑战码，⼀般是个随机字符串之类的

resp = respGenerater(code) //根据挑战码⽣成应该得到应答

echo "here is the ChallengeCode:" + code
user_input = read_input() //获取⽤户应答

if user_input == resp{ //检测⽤户应答是否正确

 echo "you are in"
}else{
 echo "out!"
}
```



## 授权方式的身份凭据

cookie 比较少 基本没用 太容易被修改了  越权可能会遇到

### session 

认证成功 后端会⽣成session_id，并且将该session_id存在某个地⽅。 

1. 在认证结束的返回（response）中，进⾏set-cookie将session_id告知客户端浏览器

2. 客户端在后续的访问中携带session_Id进⾏访问（持有身份凭证）

3. 从某个地⽅检查该session_id的有效性（鉴权）

4. 根据鉴权结果，确定是否有权限进⾏某动作。 那么，这⾥就有两个问题了。

   sessionid存储模式 存储在cookie里面 不需要服务器存储  或者 作为URL的一部分 比如Tomcat用这种机制叫做jsessionid  但服务端需要存储session 

1.进⾏set-cookie就有xss的⻛险 或者盗取 截取返回包

我们知道xss的危害在于攻击者可以在受害者的浏览器中执⾏js代码。那么如果此时可以 通过js来读取cookie，是不是就相当于窃取了⽤户的凭证了。

2.某个地⽅的⻛险 

不同的语⾔、框架，对于session的存储⽅式都不相同。这个很重要，关乎各种攻击⽅式 能不能⽤

**php** 

**默认存储在服务端/tmp⽬录下(⽂件)**

**flask** 

**默认存储在⽤户的cookie中（密钥加密）**

**java** 

**默认存储在内存中**  可dump分析

**gin（go）/其他可选的地⽅** 

**redis/mysql/memcached/mongodb**

**对于权限来说 最主要的是认清数据平面 一个数据平面对于另一个数据平面 往往是降维打击**

在js层⾯，做各种混淆、各种加密，都只是浏览器层⾯的。只要他不涉及通信 协议加密，那么我⼀个burp是不是解决所有问题？ 所以，对应于以上的session的存储位置，换⼀个数据平⾯来看，往往会有不同的撸点。换位思考

session存储于⽂件 

⽆法对抗/tmp⽬录⽂件读取利⽤，通过读取⽂件列表获取⽤户凭证

session存储于数据库中 

存在sql注⼊或者其他可以从数据库中读取信息的⽅式

session存储于redis中 

如果有⽅式可以获取到所有的键名（redis基于key-value来存储数据，⼀般存储session

时，key为session_ID，value为session内容

`session` 更适用于需要在服务器端保持状态的传统 Web 应用程序，但存储于进程内存、⽂件的⽅式，不适配于⽬前常⻅的负载均衡+微服务架构合理而 `JWT` 更适用于分布式系统



 在认证系统中，"有状态"通常指的是服务端需要保存用户的认证状态



# JWT

**jwt认证的安全性 等同于密钥的机密性** 

`JWT` 是一种无状态的令牌，以JSON对象的形式在各⽅之间安全地传输信息  同时使⽤密钥(比如HMAC算法)或RSA或ECDSA的公钥/私钥对JWT进⾏签名，这些信息被签名后形成一个令牌，是目前最流行的跨域解决方案，一般用作授权和信息交换

JWT的组成  三部分 Header Payload Signature 由点分隔  比如xxx.yyy.zzz

头部由两部分组成 令牌的类型jwt和使用的签名算法  通常由base64编码形成一个JSON对象

中间由有关实体和其他数据声明组成  注册 公开 私有三个声明  如头部

尾部 Signature 部分是对前两部分的签名，防止数据篡改 使用特定的密钥 和头部的签名算法生成 通常base64编码后形成一个字符串

输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。比如

```text
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJpYXQiOjE1OTM5NTU5NDMsInVpZCI6MTAsImV4cCI6MTU5Mzk1NTk3Mywic2NvcGVzIjpbImFkbWluIiwidXNlciJdfQ.VHpxmxKVKpsn2Iytqc_6Z1U1NtiX3EgVki4PmA-J3Pg"
```

JWT是无状态授权机制，服务器的受保护路由将Header中检查有效的token,如果存在，则将允许用户访问受保护的资源。如果JWT包含必要的数据，则可以减少查询数据库中某些操作的需求。

token是一种用于表示身份权限和访问令牌的令牌 比如jwt  jwt是token的一种实现方式,类似的还有签名字符串 OAuth2



JWT 的认证流程 客户端向认证服务器发起认证 认证完毕后获得JWT  客户端收到 JWT 后，将其存储在 Cookie 或 localStorage 中，每次请求都会带上这个 JWT，放在请求头的 Authorization 字段中，访问应用服务器的时候通过算法签名验证JWT的有效性 有效则通过返回申请的资源

`refresh_token` 是 OAuth 2.0 协议中的一种授权凭证，用于在访问令牌（access token）过期或失效时，获取新的访问令牌而无需用户重新进行身份验证，**refresh_token的过期时间长于token的过期时间**

![img](https://pic4.zhimg.com/v2-b034c3453cd2bb7177cfdbb4366a5e73_r.jpg)





通常，`JWT` 会被发送给客户端，然后客户端将其存储在本地，例如在浏览器的 `localStorage` 或 `sessionStorage` 中。因为 `JWT` 包含了所有必要的信息，所以服务器不需要存储任何会话状态。这种方式适用于分布式系统和无状态的 API，因为用户状态永远不会保存在服务器内存中。 服务器受保护的路由将在授权头中检查有效的JWT，如果存在，则允许用户访问受保护的资源。 由于JWT是独立的，所有必要的信息都在那里，减少了多次查询数据库的需求。

这使得我们可以完全依赖无状态的数据API，甚至向下游服务提出请求。 无论哪些域正在为API提供服务并不重要，因此不会出现跨域资源共享（CORS）的问题，因为它不使用Cookie

Web Storage API 是Web 浏览器提供的客户端存储数据的机制， 提供了两个对象，即 `localStorage` 和 `sessionStorage`，用于在浏览器中存储数据。这两个对象都允许开发者在客户端存储简单的键值对数据，以便在页面之间保持状态或者进行数据的持久化存储

**除了这两个以外常规的还可以存储于cookie和内存**

`localStorage` 是 Web 浏览器提供的一种客户端存储数据的机制。它是 Web Storage API 的一部分，用于在浏览器中持久化地存储键值对数据。与 `sessionStorage` 不同，`localStorage` 中存储的数据在浏览器关闭后仍然保持存在，直到通过代码或用户手动清除

### localStorage:

1. **持久性：** 数据存储在 `localStorage` 中是持久的，即使用户关闭浏览器窗口或重新启动计算机，数据仍然保持存在。
2. **同源策略：** `localStorage` 遵循同源策略，即只能访问相同协议、主机和端口的页面存储的数据。
3. **共享：** 数据存储在 `localStorage` 中的话，即使页面被关闭，其他相同源的页面仍然可以访问这些数据。
4. **大小限制：** 不同浏览器对 `localStorage` 的存储空间有不同的限制，通常在 5MB 到 10MB 之间。

### sessionStorage:

1. **会话级别：** 数据存储在 `sessionStorage` 中是会话级别的，即数据仅在当前会话期间有效。一旦用户关闭浏览器窗口，数据就会被清除。
2. **同源策略：** `sessionStorage` 同样遵循同源策略，只能在相同协议、域名和端口的页面之间共享。
3. **单页面共享：** 数据存储在 `sessionStorage` 中的话，只有在同一个页面打开的不同标签或窗口之间可以共享。
4. **大小限制：** 与 `localStorage` 一样，不同浏览器对 `sessionStorage` 的存储空间有不同的限制

1.jwt可以解决xss吗？

 不可以，jwt认证通过后，获取的token，浏览器⼀样需要保存的，那么保存在哪⾥，保存在哪 ⾥都会被xss获取到，因为xss获取的是浏览器js的权限。

2.jwt可以解决csrf吗？

 大多数情况下，JWT 被手动添加到请求的头部中进行携带。在这种情况下，由于 CSRF 攻击通常依赖于在不同域之间进行请求的方式，因为浏览器默认不会自动携带跨域请求的头部（同源策略），所以攻击者在 Evil 域中无法在请求中携带 App 域的 JWT，从而阻止了 CSRF 攻击。

Evil域是指具有恶意意图的域或域名，通常由攻击者控制     App域 表示目标应用程序所在的域或域名

但如果开发者将 JWT 存储在 Cookie 中，并在请求中自动携带。在这种情况下，JWT 将被浏览器自动添加到每个请求的头部，包括跨域请求。这就产生了一个潜在的风险，因为 CSRF 攻击者可以通过在 Evil 域中嵌入一个链接，触发用户的浏览器向 App 域发送包含 JWT 的请求，绕过了跨域请求的限制。

[JWT的安全问题 - tomyyyyy - 博客园 (cnblogs.com)](https://www.cnblogs.com/tomyyyyy/p/15134420.html#jwt的定义)